---
layout: post
title: "백준 1078 뒤집음"
date: 2022-02-26
categories:
- boj
tags:
- 수학
---

## 풀이 아이디어
[문제 링크](https://www.acmicpc.net/problem/1078)  
어려운 수학적 문제이다. 여러 과정을 통해 상수 시간에 가까운 풀이를 얻었다.  
이 글은 풀이를 얻기 위해 어떠한 생각을 거쳤는지 설명하는 글이다.  

### D가 9의 배수가 아닐 경우 만족하는 x가 없음 증명
x = $ a_{0}10^{n-1} + a_{1}10^{n-1} + ... + a_{n-1}10^0 $ 이면,  
x를 뒤집은 수 = $ a_{n-1}10^{n-1} + a_{n-2}10^{n-1} + ... + a_{0}10^0 $  
x-(x를 뒤집은 수) = $ a_{0}(10^{n-1}-10^0) + a_{1}(10^{n-2}-10^1) + ... $ 이다.   
$ (10^n-10^m) \equiv 0 $  $ (mod 9) $  $ (n, m \geq 0) $가 항상 성립하므로, x-(x를 뒤집은 수)는 무조건 9의 배수이다.  
그렇다면 D가 9의 배수이면 무조건 만족하는 x가 있을까? 정답은 **No** 이다. 이유는 밑에서 설명하겠다.  

### 관찰력으로 얻은 사실
위에서 얻은 식 $ a_{0}(10^{n-1}-10^0) + a_{1}(10^{n-2}-10^1) + ... $ 에서 N이 5일 때를 예로 들자.  
$ a_{0}(10^4-10^0) + a_{1}(10^3-10^1) + a_{2}(10^2-10^2) + a_{3}(10^1-10^3) + a_{4}(10^0-10^4) $  
= $ 9999(a_{0}-a_{4}) + 990(a_{1}-a_{3}) $ 이다. 이 식을 잘 관찰해 **두 가지** 아이디어를 얻었다.  
**첫 번째**는 $ -9 \leq a_{i}-a_{j} \leq 9 $가 항상 성립하기 때문에, D를 얻기 위해 그리디적으로 접근해도 된다는 사실이다.  
예를 들어 D = 9999인 다섯자리 X를 찾는다고 하자. 그러면 무조건 $ a_{0}-a_{4} $는 1이어야 한다. 0이 된다면 뒤의 수에서 9999로 채울 수 없다.  
이는 일반화가 가능하다. 계수는 $ 10^n-10^m $, $10^{n-1}-10^{m+1}$ 순서로 작아지고,  
$(10 \times 10^{n-1}-10^{m+1}) \geq 10^n-10^m$ 이기 때문이다. 

**두 번째**는 $ -9 \leq a_{0}-a_{4} \leq 9 $이고, $ (a_{0},a_{4}) $ 조합은 x를 작게 만들기 위해 한정지을 수 있다는 점이다.  
예를 추가로 들자면, 52894나 10870이나 똑같은 D값을 갖는데, 오른쪽 수가 훨씬 작다. 

## 최종 소스 코드
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    
    ll d; cin >> d;
    ll ten[18]; ten[0]=1;
    for (int i = 1; i < 18; i++) ten[i] = ten[i-1] * 10;

    for (int i = 2; i <= 18; i++) {
        int n = (i/2);
        vector<ll> ten1;
        vector<ll> v1;
        ll t = d;
        for (int j = 0; j < n; j++) {
            ten1.push_back((ten[i-j-1]-ten[j]) / ten[j]);
        }
        for (int j = 0; j < n; j++) {
            int a;
            if (t >= 0) a = (10-t%10)%10;
            else a = (-10-t%10)%10;
            v1.push_back(a);
            t = (t - a * ten1[j])/10;
        }
        if (t == 0) {
            ll ans = 0;
            for (int j = 0; j < n; j++) {
                if (v1[j] == 0 && j == 0) ans += ten[i-1]+ten[0];
                if (v1[j] > 0) ans += (ten[i-1-j] * v1[j]);
                if (v1[j] < 0) ans -= (ten[j] * v1[j]);
            }
            cout << ans;
            return 0;
        }
    }
    cout << "-1";
}
```
