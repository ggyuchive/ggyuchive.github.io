---
layout: post
title: "백준 1078. 뒤집음"
date: 2022-02-26
categories:
- boj
tags:
- 수학
---

## 풀이 아이디어
[문제 링크](https://www.acmicpc.net/problem/1078) 
어려운 수학 문제이다. 여러 과정을 통해 상수 시간에 가까운 풀이를 얻었다.  
이 글은 풀이를 얻기 위해 어떠한 생각을 거쳤는지 설명하는 글이다.  

### 1) D가 9의 배수가 아닐 경우 만족하는 x가 없다.  
$ x = a_{0}10^{n-1} + a_{1}10^{n-1} + ... + a_{n-1}10^0 $ 이면,  
$ (x를 뒤집은 수) = a_{n-1}10^{n-1} + a_{n-2}10^{n-1} + ... + a_{0}10^0 $  
$ x - (x를 뒤집은 수) = a_{0}(10^{n-1}-10^0) + a_{1}(10^{n-2}-10^1) + ... 이다.  
$ 10^n \equiv 1 (mod 9) (n \geq 0) $가 항상 성립하므로, $ x - (x를 뒤집은 수) $는 무조건 9의 배수이다.

## 최종 소스 코드
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    
    ll d; cin >> d;
    ll ten[18]; ten[0]=1;
    for (int i = 1; i < 18; i++) ten[i] = ten[i-1] * 10;

    for (int i = 2; i <= 18; i++) {
        int n = (i/2);
        vector<ll> ten1;
        vector<ll> v1;
        ll t = d;
        for (int j = 0; j < n; j++) {
            ten1.push_back((ten[i-j-1]-ten[j]) / ten[j]);
        }
        for (int j = 0; j < n; j++) {
            int a;
            if (t >= 0) a = (10-t%10)%10;
            else a = (-10-t%10)%10;
            v1.push_back(a);
            t = (t - a * ten1[j])/10;
        }
        if (t == 0) {
            ll ans = 0;
            for (int j = 0; j < n; j++) {
                if (v1[j] == 0 && j == 0) ans += ten[i-1]+ten[0];
                if (v1[j] > 0) ans += (ten[i-1-j] * v1[j]);
                if (v1[j] < 0) ans -= (ten[j] * v1[j]);
            }
            cout << ans;
            return 0;
        }
    }
    cout << "-1";
}
```
